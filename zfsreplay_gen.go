// Code generated by cmd/cgo -godefs; DO NOT EDIT.
// cgo -godefs zfsreplay.go

package gozfsreplay

import (
	"encoding/binary"
	"errors"
	"os"
)

type ZIO_cksum struct {
	Word [4]uint64
}
type DDT_key struct {
	Cksum	ZIO_cksum
	Prop	uint64
}
type DRR_begin struct {
	Magic		uint64
	Versioninfo	uint64
	Creation_time	uint64
	Type		uint32
	Flags		uint32
	Toguid		uint64
	Fromguid	uint64
	Toname		[256]int8
}
type DRR_end struct {
	Checksum	ZIO_cksum
	Toguid		uint64
}
type DRR_object struct {
	Object		uint64
	Type		uint32
	Bonustype	uint32
	Blksz		uint32
	Bonuslen	uint32
	Checksumtype	uint8
	Compress	uint8
	Dn_slots	uint8
	Flags		uint8
	Raw_bonuslen	uint32
	Toguid		uint64
	Indblkshift	uint8
	Nlevels		uint8
	Nblkptr		uint8
	Pad		[5]uint8
	Maxblkid	uint64
}
type DRR_freeobjects struct {
	Firstobj	uint64
	Numobjs		uint64
	Toguid		uint64
}
type DRR_write struct {
	Object		uint64
	Type		uint32
	Pad		uint32
	Offset		uint64
	Logical_size	uint64
	Toguid		uint64
	Checksumtype	uint8
	Flags		uint8
	Compressiontype	uint8
	Pad2		[5]uint8
	Key		DDT_key
	Compressed_size	uint64
	Salt		[8]uint8
	Iv		[12]uint8
	Mac		[16]uint8
	Pad_cgo_0	[4]byte
}
type DRR_free struct {
	Object	uint64
	Offset	uint64
	Length	uint64
	Toguid	uint64
}
type DRR_write_byref struct {
	Object		uint64
	Offset		uint64
	Length		uint64
	Toguid		uint64
	Refguid		uint64
	Refobject	uint64
	Refoffset	uint64
	Checksumtype	uint8
	Flags		uint8
	Pad2		[6]uint8
	Key		DDT_key
}
type DRR_spill struct {
	Object		uint64
	Length		uint64
	Toguid		uint64
	Flags		uint8
	Compressiontype	uint8
	Pad		[6]uint8
	Compressed_size	uint64
	Salt		[8]uint8
	Iv		[12]uint8
	Mac		[16]uint8
	Type		uint32
}
type DRR_write_embedded struct {
	Object		uint64
	Offset		uint64
	Length		uint64
	Toguid		uint64
	Compression	uint8
	Etype		uint8
	Pad		[6]uint8
	Lsize		uint32
	Psize		uint32
}
type DRR_object_range struct {
	Firstobj	uint64
	Numslots	uint64
	Toguid		uint64
	Salt		[8]uint8
	Iv		[12]uint8
	Mac		[16]uint8
	Flags		uint8
	Pad		[3]uint8
}
type DRR_redact struct {
	Object	uint64
	Offset	uint64
	Length	uint64
	Toguid	uint64
}
type DRR_checksum struct {
	Pad		[34]uint64
	Checksum	ZIO_cksum
}
type DRR_replay_record struct {
	Type		uint32
	Payloadlen	uint32
	U		[304]byte
}
type DRR_replay_header struct {
	Type		uint32
	Payloadlen	uint32
}

const Sizeof_ZIO_cksum = 0x20
const Sizeof_DRR_replay_record = 0x138
const Sizeof_DRR_replay_header = 0x8
const Sizeof_DRR_freeobjects = 0x18
const Sizeof_DRR_object = 0x38
const Sizeof_DRR_free = 0x20
const Sizeof_DRR_write = 0x88

func (w DRR_write) DRR_write_compressed() bool {
	return w.Compressiontype != 0
}

func (w DRR_write) DRR_write_payload_size() uint64 {
	if w.DRR_write_compressed() {
		return w.Compressed_size
	}
	return w.Logical_size
}

type DRR_type uint32

const (
	DRR_BEGIN	DRR_type	= iota
	DRR_OBJECT
	DRR_FREEOBJECTS
	DRR_WRITE
	DRR_FREE
	DRR_END
	DRR_WRITE_BYREF
	DRR_SPILL
	DRR_WRITE_EMBEDDED
	DRR_OBJECT_RANGE
	DRR_REDACT
	DRR_NUMTYPES
)

func DRRRead(r *os.File, order binary.ByteOrder) (interface{}, DRR_type, error) {
	if order != binary.LittleEndian {
		return nil, 0, errors.New("zfs: currently only binary.LittleEndian is supported")
	}

	hdr := DRR_replay_header{}
	err := binary.Read(r, order, &hdr)
	if err != nil {
		return nil, 0, err
	}

	var off int64
	typ := DRR_type(hdr.Type)
	switch typ {
	case DRR_BEGIN:
		obj := DRR_begin{}
		if err := binary.Read(r, order, &obj); err != nil {
			return obj, typ, err
		}
		return obj, typ, nil
	case DRR_FREEOBJECTS:
		off = Sizeof_DRR_freeobjects
		obj := DRR_freeobjects{}
		if err := binary.Read(r, order, &obj); err != nil {
			return obj, typ, err
		}
		return obj, typ, forward(r, hdr, off)
	case DRR_OBJECT:
		off = Sizeof_DRR_object
		obj := DRR_object{}
		if err := binary.Read(r, order, &obj); err != nil {
			return obj, typ, err
		}
		return obj, typ, forward(r, hdr, off)
	case DRR_FREE:
		off = Sizeof_DRR_free
		obj := DRR_free{}
		if err := binary.Read(r, order, &obj); err != nil {
			return obj, typ, err
		}
		return obj, typ, forward(r, hdr, off)
	case DRR_WRITE:
		off = Sizeof_DRR_write
		obj := DRR_write{}
		if err := binary.Read(r, order, &obj); err != nil {
			return obj, typ, err
		}
		if _, err := r.Seek(int64(obj.DRR_write_payload_size()), 1); err != nil {
			return obj, typ, err
		}
		return obj, typ, forward(r, hdr, off)
	case DRR_END:
		obj := DRR_end{}
		if err := binary.Read(r, order, &obj); err != nil {
			return obj, typ, err
		}
		return obj, typ, nil
	default:
		return nil, 0, errors.New("zfs: unknown type")
	}

	return nil, 0, errors.New("zfs: unknown type")
}

func forward(f *os.File, hdr DRR_replay_header, off int64) error {
	typ := DRR_type(hdr.Type)
	if typ != DRR_BEGIN {
		off = Sizeof_DRR_replay_record - Sizeof_DRR_replay_header - off
		if _, err := f.Seek(off, 1); err != nil {
			return err
		}
	}
	if _, err := f.Seek(int64(hdr.Payloadlen), 1); err != nil {
		return err
	}
	return nil
}
